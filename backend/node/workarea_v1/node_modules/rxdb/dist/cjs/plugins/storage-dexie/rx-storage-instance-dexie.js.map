{"version":3,"file":"rx-storage-instance-dexie.js","names":["_rxjs","require","_index","_dexieHelper","_dexieQuery","_rxSchemaHelper","_rxStorageHelper","_rxStorageMultiinstance","_rxError","instanceId","now","DEXIE_TEST_META_FIELD","exports","RxStorageInstanceDexie","storage","databaseName","collectionName","schema","internals","options","settings","devMode","changes$","Subject","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","_proto","prototype","bulkWrite","documentWrites","context","ensureNotClosed","forEach","row","document","_rev","previous","newRxError","args","_meta","console","dir","Error","state","ret","success","error","map","doc","flatCloneDocWithMeta","documentKeys","writeRow","categorized","dexieDb","transaction","dexieTable","dexieAttachmentsTable","docsInDbMap","Map","docsInDbWithInternals","getDocsInDb","docWithDexieInternals","set","categorizeBulkWriteRows","errors","bulkPutDocs","bulkInsertDocs","push","bulkUpdateDocs","d","fromStorageToDexie","booleanIndexes","length","bulkPut","putAttachments","attachmentsAdd","attachment","id","attachmentObjectId","documentId","attachmentId","data","attachmentData","attachmentsUpdate","bulkDelete","attachmentsRemove","ensureNotFalsy","eventBulk","events","lastState","newestRow","checkpoint","lwt","endTime","next","findDocumentsById","ids","deleted","docsInDb","documentInDb","_deleted","query","preparedQuery","dexieQuery","count","queryPlan","selectorSatisfiedByIndex","result","dexieCount","mode","documents","changeStream","asObservable","cleanup","minimumDeletedTime","maxDeletionTime","toRemove","where","below","toArray","removeIds","getAttachmentData","_digest","get","remove","clear","close","closed","complete","closeDexieDb","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","createDexieStorageInstance","params","getDexieDbWithTables","instance","addRxStorageMultiInstanceSupport","RX_STORAGE_NAME_DEXIE","Promise","resolve"],"sources":["../../../../src/plugins/storage-dexie/rx-storage-instance-dexie.ts"],"sourcesContent":["import {\n    Subject,\n    Observable\n} from 'rxjs';\nimport {\n    now,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM,\n    sortDocumentsByLastWriteTime,\n    lastOfArray,\n    ensureNotFalsy,\n    randomCouchString\n} from '../utils/index.ts';\nimport type {\n    RxStorageInstance,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageQueryResult,\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    EventBulk,\n    StringKeys,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxStorageDefaultCheckpoint,\n    CategorizeBulkWriteRowsOutput,\n    RxStorageCountResult,\n    PreparedQuery\n} from '../../types/index.d.ts';\nimport type {\n    DexieSettings,\n    DexieStorageInternals\n} from '../../types/plugins/dexie.d.ts';\nimport { RxStorageDexie } from './rx-storage-dexie.ts';\nimport {\n    attachmentObjectId,\n    closeDexieDb,\n    fromDexieToStorage,\n    fromStorageToDexie,\n    getDexieDbWithTables,\n    getDocsInDb,\n    RX_STORAGE_NAME_DEXIE\n} from './dexie-helper.ts';\nimport { dexieCount, dexieQuery } from './dexie-query.ts';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\nimport { categorizeBulkWriteRows, flatCloneDocWithMeta } from '../../rx-storage-helper.ts';\nimport { addRxStorageMultiInstanceSupport } from '../../rx-storage-multiinstance.ts';\nimport { newRxError } from '../../rx-error.ts';\n\nlet instanceId = now();\nexport const DEXIE_TEST_META_FIELD = 'dexieTestMetaField';\n\nexport class RxStorageInstanceDexie<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    DexieStorageInternals,\n    DexieSettings,\n    RxStorageDefaultCheckpoint\n> {\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed?: Promise<void>;\n\n    constructor(\n        public readonly storage: RxStorageDexie,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: DexieStorageInternals,\n        public readonly options: Readonly<DexieSettings>,\n        public readonly settings: DexieSettings,\n        public readonly devMode: boolean\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotClosed(this);\n\n\n        /**\n         * Check some assumptions to ensure RxDB\n         * does not call the storage with an invalid write.\n         */\n        documentWrites.forEach(row => {\n            // ensure revision is set\n            if (\n                !row.document._rev ||\n                (\n                    row.previous &&\n                    !row.previous._rev\n                )\n            ) {\n                throw newRxError('SNH', { args: { row } });\n            }\n\n            // ensure prev-data is set\n            if (this.devMode) {\n                if (\n                    row.previous &&\n                    (\n                        !row.previous._meta[DEXIE_TEST_META_FIELD] ||\n                        row.previous._meta[DEXIE_TEST_META_FIELD] !== row.previous._rev\n                    )\n                ) {\n                    console.dir(row);\n                    throw new Error('missing or wrong _meta.' + DEXIE_TEST_META_FIELD);\n                }\n            }\n        });\n\n        const state = await this.internals;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: [],\n            error: []\n        };\n\n        /**\n         * Some storages might add any _meta fields\n         * internally. To ensure RxDB can work with that in the\n         * test suite, we add a random field here.\n         * To ensure \n         */\n        if (this.devMode) {\n            documentWrites = documentWrites.map(row => {\n                const doc = flatCloneDocWithMeta(row.document);\n                doc._meta[DEXIE_TEST_META_FIELD] = doc._rev;\n                return {\n                    previous: row.previous,\n                    document: doc\n                }\n            })\n        }\n\n\n        const documentKeys: string[] = documentWrites.map(writeRow => writeRow.document[this.primaryPath] as any);\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> | undefined;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieTable,\n            state.dexieAttachmentsTable,\n            async () => {\n                const docsInDbMap = new Map<string, RxDocumentData<RxDocType>>();\n                const docsInDbWithInternals = await getDocsInDb<RxDocType>(this.internals, documentKeys);\n                docsInDbWithInternals.forEach(docWithDexieInternals => {\n                    const doc = docWithDexieInternals;\n                    if (doc) {\n                        docsInDbMap.set((doc as any)[this.primaryPath], doc as any);\n                    }\n                    return doc;\n                });\n\n                categorized = categorizeBulkWriteRows<RxDocType>(\n                    this,\n                    this.primaryPath as any,\n                    docsInDbMap,\n                    documentWrites,\n                    context\n                );\n                ret.error = categorized.errors;\n\n                /**\n                 * Batch up the database operations\n                 * so we can later run them in bulk.\n                 */\n                let bulkPutDocs: any[] = [];\n                categorized.bulkInsertDocs.forEach(row => {\n                    ret.success.push(row.document);\n                    bulkPutDocs.push(row.document);\n                });\n                categorized.bulkUpdateDocs.forEach(row => {\n                    ret.success.push(row.document);\n                    bulkPutDocs.push(row.document);\n                });\n                bulkPutDocs = bulkPutDocs.map(d => fromStorageToDexie(state.booleanIndexes, d));\n                if (bulkPutDocs.length > 0) {\n                    await state.dexieTable.bulkPut(bulkPutDocs);\n                }\n\n                // handle attachments\n                const putAttachments: { id: string, data: string }[] = [];\n                categorized.attachmentsAdd.forEach(attachment => {\n                    putAttachments.push({\n                        id: attachmentObjectId(attachment.documentId, attachment.attachmentId),\n                        data: attachment.attachmentData.data\n                    });\n                });\n                categorized.attachmentsUpdate.forEach(attachment => {\n                    putAttachments.push({\n                        id: attachmentObjectId(attachment.documentId, attachment.attachmentId),\n                        data: attachment.attachmentData.data\n                    });\n                });\n                await state.dexieAttachmentsTable.bulkPut(putAttachments);\n                await state.dexieAttachmentsTable.bulkDelete(\n                    categorized.attachmentsRemove.map(attachment => attachmentObjectId(attachment.documentId, attachment.attachmentId))\n                );\n\n            });\n\n        categorized = ensureNotFalsy(categorized);\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            categorized.eventBulk.endTime = now();\n            this.changes$.next(categorized.eventBulk);\n        }\n\n        return ret;\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        deleted: boolean\n    ): Promise<RxDocumentData<RxDocType>[]> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const ret: RxDocumentData<RxDocType>[] = [];\n\n        await state.dexieDb.transaction(\n            'r',\n            state.dexieTable,\n            async () => {\n                const docsInDb = await getDocsInDb<RxDocType>(this.internals, ids);\n                docsInDb.forEach(documentInDb => {\n                    if (\n                        documentInDb &&\n                        (!documentInDb._deleted || deleted)\n                    ) {\n                        ret.push(documentInDb);\n                    }\n                });\n            });\n        return ret;\n    }\n\n    query(preparedQuery: PreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        ensureNotClosed(this);\n        return dexieQuery(\n            this,\n            preparedQuery\n        );\n    }\n    async count(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {\n            const result = await dexieCount(this, preparedQuery);\n            return {\n                count: result,\n                mode: 'fast'\n            };\n        } else {\n            const result = await dexieQuery(this, preparedQuery);\n            return {\n                count: result.documents.length,\n                mode: 'slow'\n            };\n        }\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotClosed(this);\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieTable,\n            async () => {\n                const maxDeletionTime = now() - minimumDeletedTime;\n                /**\n                 * TODO only fetch _deleted=true\n                 */\n                const toRemove = await state.dexieTable\n                    .where('_meta.lwt')\n                    .below(maxDeletionTime)\n                    .toArray();\n                const removeIds: string[] = [];\n                toRemove.forEach(doc => {\n                    if (doc._deleted === '1') {\n                        removeIds.push(doc[this.primaryPath]);\n                    }\n                });\n                await state.dexieTable.bulkDelete(removeIds);\n            }\n        );\n\n        /**\n         * TODO instead of deleting all deleted docs at once,\n         * only clean up some of them and return false if there are more documents to clean up.\n         * This ensures that when many documents have to be purged,\n         * we do not block the more important tasks too long.\n         */\n        return true;\n    }\n\n    async getAttachmentData(documentId: string, attachmentId: string, _digest: string): Promise<string> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const id = attachmentObjectId(documentId, attachmentId);\n        return await state.dexieDb.transaction(\n            'r',\n            state.dexieAttachmentsTable,\n            async () => {\n\n                const attachment = await state.dexieAttachmentsTable.get(id);\n                if (attachment) {\n                    return attachment.data;\n                } else {\n                    throw new Error('attachment missing documentId: ' + documentId + ' attachmentId: ' + attachmentId);\n                }\n            });\n    }\n\n    async remove(): Promise<void> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await state.dexieTable.clear()\n        return this.close();\n    }\n\n\n    close(): Promise<void> {\n        if (this.closed) {\n            return this.closed;\n        }\n        this.closed = (async () => {\n            this.changes$.complete();\n            await closeDexieDb(this.internals);\n        })();\n        return this.closed;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return new Subject();\n    }\n    async resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> { }\n\n}\n\n\nexport async function createDexieStorageInstance<RxDocType>(\n    storage: RxStorageDexie,\n    params: RxStorageInstanceCreationParams<RxDocType, DexieSettings>,\n    settings: DexieSettings\n): Promise<RxStorageInstanceDexie<RxDocType>> {\n    const internals = getDexieDbWithTables(\n        params.databaseName,\n        params.collectionName,\n        settings,\n        params.schema\n    );\n\n    const instance = new RxStorageInstanceDexie(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings,\n        params.devMode\n    );\n\n    await addRxStorageMultiInstanceSupport(\n        RX_STORAGE_NAME_DEXIE,\n        params,\n        instance\n    );\n\n    return Promise.resolve(instance);\n}\n\n\n\nfunction ensureNotClosed(\n    instance: RxStorageInstanceDexie<any>\n) {\n    if (instance.closed) {\n        throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n    }\n}\n"],"mappings":"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","ignoreList":[]}